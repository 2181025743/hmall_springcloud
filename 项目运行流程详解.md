# HMall 电商微服务系统运行流程详解

## 🏗️ 系统架构概览

```
前端 (localhost:18080)
    ↓ HTTP请求
hm-gateway (8080) - API网关
    ↓ 路由转发
┌─────────────────────────────────────────────────┐
│                微服务集群                        │
├─────────────────────────────────────────────────┤
│ item-service    商品服务                         │
│ cart-service    购物车服务 (8082)                │
│ user-service    用户服务                         │
│ trade-service   交易订单服务                     │
│ pay-service     支付服务                         │
└─────────────────────────────────────────────────┘
    ↓ 注册发现
Nacos (101.42.238.233:8848)
    ↓ 监控
Sentinel Dashboard (localhost:8858)
```

## 📋 完整业务流程：从搜索到下单支付

### 场景：用户在搜索页添加商品到购物车，然后商品降价后下单的完整流程

---

## 🔍 第一步：商品搜索

### 1.1 用户发起搜索请求
```
用户在前端输入关键词：例如"手机"
前端发送HTTP请求：GET /search/list?key=手机&page=1&size=10
```

### 1.2 网关处理
```java
// hm-gateway 接收请求
请求路径: http://localhost:8080/search/list?key=手机
网关配置:
  - 路径匹配: /search/**
  - 转发目标: lb://item-service
  - 最终转发: http://item-service/search/list?key=手机
```

### 1.3 商品服务处理搜索
```java
// item-service/SearchController.java:26
@GetMapping("/list")
public PageDTO<ItemDTO> search(ItemPageQuery query) {
    // 1. 数据库查询
    Page<Item> result = itemService.lambdaQuery()
        .like(StrUtil.isNotBlank(query.getKey()), Item::getName, query.getKey()) // 模糊匹配商品名
        .eq(Item::getStatus, 1) // 只查在售商品
        .page(query.toMpPage("update_time", false)); // 分页，按更新时间降序

    // 2. PO转DTO返回
    return PageDTO.of(result, ItemDTO.class);
}
```

### 1.4 数据库执行
```sql
-- 实际执行的SQL（MyBatis-Plus生成）
SELECT id,name,price,stock,image,category,brand,spec,sold,comment_count,isAD,status,create_time,update_time
FROM item
WHERE name LIKE '%手机%'
  AND status = 1
ORDER BY update_time DESC
LIMIT 0,10
```

### 1.5 响应数据流
```
item-service → hm-gateway → 前端
返回数据格式:
{
  "total": 50,
  "pages": 5,
  "list": [
    {
      "id": 100001,
      "name": "Apple iPhone 15",
      "price": 5999,
      "stock": 100,
      "image": "xxx.jpg"
    }
  ]
}
```

---

## 🛒 第二步：添加商品到购物车

### 2.1 用户点击加入购物车
```
前端发送请求：POST /carts
请求体: {
  "itemId": 100001,
  "num": 2
}
```

### 2.2 网关路由到购物车服务
```java
// hm-gateway 路由配置
路径匹配: /carts/**
转发目标: lb://cart-service
最终请求: http://cart-service/carts
```

### 2.3 购物车服务处理
```java
// cart-service/CartController.java:27
@PostMapping
public void addItem2Cart(@Valid @RequestBody CartFormDTO cartFormDTO) {
    cartService.addItem2Cart(cartFormDTO);
}

// cart-service/CartServiceImpl.java:42
@Override
public void addItem2Cart(CartFormDTO cartFormDTO) {
    // 1. 获取当前登录用户ID（从JWT中解析）
    Long userId = UserContext.getUser(); // 例如：userId = 2

    // 2. 检查购物车中是否已存在该商品
    if (checkItemExists(cartFormDTO.getItemId(), userId)) {
        // 2.1 存在则更新数量（+1）
        baseMapper.updateNum(cartFormDTO.getItemId(), userId);
        return;
    }

    // 2.2 不存在则新增购物车记录
    // 3. **关键点：调用商品服务获取商品信息**
    ItemDTO item = itemClient.queryItemByIds(List.of(cartFormDTO.getItemId())).get(0);

    // 4. 构造购物车对象并保存
    Cart cart = BeanUtils.copyBean(cartFormDTO, Cart.class);
    cart.setUserId(userId);
    cart.setName(item.getName());
    cart.setPrice(item.getPrice());
    cart.setImage(item.getImage());
    save(cart);
}
```

### 2.4 微服务间调用：cart-service → item-service
```java
// 这里就是我们刚才配置的Feign调用，带Fallback降级
// hm-api/ItemClient.java
@FeignClient(value = "item-service", fallbackFactory = ItemClientFallbackFactory.class)
public interface ItemClient {
    @GetMapping("/items")
    List<ItemDTO> queryItemByIds(@RequestParam("ids") Collection<Long> ids);
}

// 实际HTTP调用过程：
// 1. Feign生成代理对象
// 2. 调用: GET http://item-service/items?ids=100001
// 3. 如果失败，触发Fallback返回空集合
// 4. Sentinel监控此次调用
```

### 2.5 商品服务响应商品详情
```java
// item-service/ItemController.java:38
@GetMapping
public List<ItemDTO> queryItemByIds(@RequestParam("ids") List<Long> ids) {
    // 模拟延迟500ms（我们添加的测试代码）
    Thread.sleep(500);

    // 查询数据库
    return itemService.queryItemByIds(ids);
}
```

### 2.6 数据库操作
```sql
-- 购物车表插入
INSERT INTO cart (user_id, item_id, name, price, image, num, create_time, update_time)
VALUES (2, 100001, 'Apple iPhone 15', 5999, 'xxx.jpg', 2, NOW(), NOW());
```

---

## 💰 第三步：商品降价（管理后台操作）

### 3.1 管理员修改商品价格
```java
// item-service/ItemController.java:65
@PutMapping
public void updateItem(@RequestBody ItemDTO item) {
    // 更新商品信息（包括价格）
    itemService.updateById(BeanUtils.copyBean(item, Item.class));
}
```

### 3.2 数据库价格更新
```sql
UPDATE item
SET price = 4999, update_time = NOW()
WHERE id = 100001;
-- iPhone 15 从5999降价到4999
```

---

## 🛍️ 第四步：用户查看购物车

### 4.1 用户打开购物车页面
```
前端请求：GET /carts
```

### 4.2 购物车服务处理
```java
// cart-service/CartController.java:45
@GetMapping
public List<CartVO> queryMyCarts() {
    return cartService.queryMyCarts();
}

// cart-service/CartServiceImpl.java
@Override
public List<CartVO> queryMyCarts() {
    // 1. 获取用户ID
    Long userId = UserContext.getUser();

    // 2. 查询用户购物车
    List<Cart> carts = lambdaQuery().eq(Cart::getUserId, userId).list();
    if (CollUtils.isEmpty(carts)) {
        return CollUtils.emptyList();
    }

    // 3. **关键：再次调用商品服务获取最新商品信息**
    Set<Long> itemIds = carts.stream().map(Cart::getItemId).collect(Collectors.toSet());
    List<ItemDTO> items = itemClient.queryItemByIds(itemIds);

    // 4. 转换为Map便于查找
    Map<Long, ItemDTO> itemMap = items.stream()
        .collect(Collectors.toMap(ItemDTO::getId, Function.identity()));

    // 5. 构建购物车VO，包含最新的商品价格
    List<CartVO> vos = BeanUtils.copyList(carts, CartVO.class);
    vos.forEach(v -> {
        ItemDTO item = itemMap.get(v.getItemId());
        if (item != null) {
            v.setNewPrice(item.getPrice()); // 最新价格4999
            v.setStatus(item.getStatus());
            v.setStock(item.getStock());
        }
    });

    return vos;
}
```

### 4.3 用户看到降价信息
```json
// 返回给前端的数据
[
  {
    "id": 1,
    "itemId": 100001,
    "name": "Apple iPhone 15",
    "price": 5999,      // 加入购物车时的价格
    "newPrice": 4999,   // 当前最新价格（降价了！）
    "num": 2,
    "image": "xxx.jpg"
  }
]
```

---

## 📋 第五步：创建订单

### 5.1 用户点击结算
```
前端请求：POST /orders
请求体: {
  "cartIds": [1],  // 购物车条目ID
  "addressId": 123 // 收货地址ID
}
```

### 5.2 网关路由到交易服务
```
hm-gateway → trade-service
```

### 5.3 订单服务创建订单
```java
// trade-service/OrderController.java:29
@PostMapping
public Long createOrder(@RequestBody OrderFormDTO orderFormDTO){
    return orderService.createOrder(orderFormDTO);
}

// trade-service/OrderServiceImpl.java
@Override
public Long createOrder(OrderFormDTO orderFormDTO) {
    // 1. 获取用户ID
    Long userId = UserContext.getUser();

    // 2. **调用购物车服务**获取购物车商品信息
    List<CartVO> carts = cartClient.queryCartByIds(orderFormDTO.getCartIds());

    // 3. **调用商品服务**获取最新商品信息和价格
    Set<Long> itemIds = carts.stream().map(CartVO::getItemId).collect(Collectors.toSet());
    List<ItemDTO> items = itemClient.queryItemByIds(itemIds);
    Map<Long, ItemDTO> itemMap = items.stream()
        .collect(Collectors.toMap(ItemDTO::getId, Function.identity()));

    // 4. 计算订单金额（使用最新价格）
    int totalFee = 0;
    for (CartVO cart : carts) {
        ItemDTO item = itemMap.get(cart.getItemId());
        totalFee += item.getPrice() * cart.getNum(); // 4999 * 2 = 9998
    }

    // 5. 创建订单主记录
    Order order = new Order();
    order.setId(IdWorker.getId()); // 生成订单号，如：1836123456789
    order.setUserId(userId);
    order.setTotalFee(totalFee);
    order.setPaymentType(1);
    order.setStatus(1); // 待支付
    order.setCreateTime(LocalDateTime.now());
    save(order);

    // 6. 创建订单详情
    List<OrderDetail> details = new ArrayList<>();
    for (CartVO cart : carts) {
        OrderDetail detail = new OrderDetail();
        detail.setOrderId(order.getId());
        detail.setItemId(cart.getItemId());
        detail.setNum(cart.getNum());
        detail.setPrice(itemMap.get(cart.getItemId()).getPrice()); // 使用最新价格
        detail.setName(cart.getName());
        detail.setImage(cart.getImage());
        details.add(detail);
    }
    orderDetailService.saveBatch(details);

    // 7. **调用购物车服务**删除已下单的购物车商品
    cartClient.deleteCartItemByIds(orderFormDTO.getCartIds());

    // 8. **调用商品服务**扣减库存
    List<OrderDetailDTO> orderDetails = BeanUtils.copyList(details, OrderDetailDTO.class);
    itemClient.deductStock(orderDetails);

    return order.getId();
}
```

### 5.4 多个微服务协作
```java
// 这个过程涉及多个服务调用：

// 1. trade-service → cart-service (查询购物车)
cartClient.queryCartByIds(orderFormDTO.getCartIds())

// 2. trade-service → item-service (查询商品最新信息)
itemClient.queryItemByIds(itemIds)

// 3. trade-service → cart-service (删除购物车商品)
cartClient.deleteCartItemByIds(orderFormDTO.getCartIds())

// 4. trade-service → item-service (扣减库存)
itemClient.deductStock(orderDetails)
```

### 5.5 数据库事务操作
```sql
-- 订单主表
INSERT INTO `order` (id, user_id, total_fee, payment_type, status, create_time)
VALUES (1836123456789, 2, 9998, 1, 1, NOW());

-- 订单详情表
INSERT INTO order_detail (order_id, item_id, num, price, name, image)
VALUES (1836123456789, 100001, 2, 4999, 'Apple iPhone 15', 'xxx.jpg');

-- 扣减商品库存
UPDATE item
SET stock = stock - 2
WHERE id = 100001 AND stock >= 2;

-- 删除购物车记录
DELETE FROM cart WHERE id IN (1);
```

---

## 💳 第六步：支付流程

### 6.1 用户选择支付方式
```
前端请求：POST /pay-orders
请求体: {
  "bizOrderNo": 1836123456789, // 业务订单号
  "amount": 9998,              // 支付金额
  "payChannelCode": "zfb",     // 支付渠道
  "payType": 1                 // 余额支付
}
```

### 6.2 支付服务生成支付单
```java
// pay-service/PayController.java:24
@PostMapping
public String applyPayOrder(@RequestBody PayApplyDTO applyDTO){
    // 检查只支持余额支付
    if(!PayType.BALANCE.equalsValue(applyDTO.getPayType())){
        throw new BizIllegalException("抱歉，目前只支持余额支付");
    }
    return payOrderService.applyPayOrder(applyDTO);
}

// pay-service/PayOrderServiceImpl.java
@Override
public String applyPayOrder(PayApplyDTO applyDTO) {
    // 1. 创建支付单
    PayOrder payOrder = new PayOrder();
    payOrder.setId(IdWorker.getId()); // 生成支付单ID：1836123456790
    payOrder.setBizOrderNo(applyDTO.getBizOrderNo()); // 关联业务订单号
    payOrder.setAmount(applyDTO.getAmount());
    payOrder.setPayChannelCode(applyDTO.getPayChannelCode());
    payOrder.setStatus(PayStatus.WAIT_BUYER_PAY.getValue()); // 等待支付
    save(payOrder);

    return payOrder.getId().toString();
}
```

### 6.3 用户确认支付
```
前端请求：POST /pay-orders/1836123456790
请求体: {
  "pw": "123456"  // 支付密码
}
```

### 6.4 余额支付处理
```java
// pay-service/PayController.java:35
@PostMapping("{id}")
public void tryPayOrderByBalance(@PathVariable("id") Long id, @RequestBody PayOrderFormDTO payOrderFormDTO){
    payOrderService.tryPayOrderByBalance(payOrderFormDTO);
}

// pay-service/PayOrderServiceImpl.java
@Override
public void tryPayOrderByBalance(PayOrderFormDTO payOrderFormDTO) {
    // 1. 查询支付单
    PayOrder payOrder = getById(payOrderFormDTO.getId());

    // 2. **调用用户服务**扣减用户余额
    userClient.deductMoney(payOrderFormDTO.getPw(), payOrder.getAmount());

    // 3. 更新支付单状态为已支付
    payOrder.setStatus(PayStatus.TRADE_SUCCESS.getValue());
    payOrder.setPaySuccessTime(LocalDateTime.now());
    updateById(payOrder);

    // 4. **调用交易服务**通知订单支付成功
    tradeClient.markOrderPaySuccess(payOrder.getBizOrderNo());
}
```

### 6.5 订单状态更新
```java
// trade-service 接收支付成功通知
// trade-service/OrderController.java:36
@PutMapping("/{orderId}")
public void markOrderPaySuccess(@PathVariable("orderId") Long orderId) {
    orderService.markOrderPaySuccess(orderId);
}

// trade-service/OrderServiceImpl.java
@Override
public void markOrderPaySuccess(Long orderId) {
    // 更新订单状态为已支付
    Order order = new Order();
    order.setId(orderId);
    order.setStatus(2); // 待发货
    order.setPayTime(LocalDateTime.now());
    updateById(order);

    // 可以在这里添加其他业务逻辑，如：
    // - 发送短信通知
    // - 通知仓库发货
    // - 记录支付日志等
}
```

---

## 🔄 微服务调用链路图

```
用户搜索商品：
前端 → hm-gateway → item-service → 数据库

添加购物车：
前端 → hm-gateway → cart-service → item-service → 数据库
                      ↓
                   数据库(cart表)

查看购物车：
前端 → hm-gateway → cart-service → item-service → 数据库
                      ↓
                   返回最新价格

创建订单：
前端 → hm-gateway → trade-service ┬→ cart-service → 数据库
                                 ├→ item-service → 数据库
                                 └→ 数据库(order表)

支付订单：
前端 → hm-gateway → pay-service ┬→ user-service → 数据库
                                ├→ trade-service → 数据库
                                └→ 数据库(pay_order表)
```

## 🛡️ 容错机制

### Sentinel + Feign Fallback
- 当任何微服务调用失败时，触发Fallback机制
- 查询类操作：返回空数据，保证系统可用
- 关键业务操作：记录日志并抛异常，确保数据一致性

### 示例：商品服务异常时
```java
// 如果item-service宕机或响应超时
// cart-service调用item-service失败时:
List<ItemDTO> items = itemClient.queryItemByIds(itemIds);
// ↓ 触发Fallback
// ItemClientFallbackFactory.create() 返回空集合
// ↓ 购物车页面显示商品基本信息，但价格可能不是最新的
```

---

## 📊 关键数据流转

1. **用户信息**: JWT Token → UserContext.getUser() → 各服务获取当前用户
2. **商品信息**: item-service → 其他服务 → 保证价格和库存准确性
3. **订单状态**: trade-service → pay-service → trade-service (状态同步)
4. **库存扣减**: trade-service → item-service (原子操作)

## 🔍 性能优化点

1. **缓存策略**: 商品信息可以加入Redis缓存
2. **数据库优化**: 关键查询添加索引
3. **异步处理**: 非关键业务可异步执行
4. **连接池**: 数据库和HTTP连接池调优

这就是HMall电商系统从搜索到支付的完整业务流程！每个环节都体现了微服务架构的特点：服务拆分、独立部署、服务间通信。